## 4. 기본형(Primitive type)


### 4-1. 논리형(boolean)
논리형 변수에는 true, false 중 하나를 저장할 수 있다.(default: false)
대답(yes/no)이나 스위치(on/off) 등의 논리구현에 주로 사용된다.
(자바에서 논리형 변수 초기화 시에는 소문자를 이용해야 한다.)

```java
boolean power = true;
boolean button = false;
```
---
### 4-2. 문자형(char)
단 하나의 문자를 저장할 수 있다.

```java
char ch = 'A';
char ch = 65;
```
실제로 저장되는 값은 문자가 아닌 문자에 해당하는 유니코드 값(정수)가 저장된다.
예제의 경우 문자 'A'의 유니코드는 65이기때문에 ch에는 65가 저장된다.
문자형으로 선언된 글자에 정수를 저장할 경우 동일한 값에 해당하는 유니코드 문자 값이 저장된다.

이러한 문자형 변수는 정수값으로 형변환(casting)할 수 있다.
문자형 변수에 문자 리터럴 대신 유니코드를 직접 사용할 수도 있다.

```java
int uniCode = (int) ch; 
```


영문자 외에 특수문자를 저장할 때는 역슬래시(\)를 이용한다.
#### 특수문자 표기법

| 특수문자         | 문자리터럴      |
|--------------|------------|
| tab          | \t         | 
| backspace    | \b         |
| form feed    | \f         |
| new line     | \n         |
| carriage     | \r         |
| 역슬래쉬      | \\\        |    
| 작은따옴표      | \\\'       |
| 큰따옴표         | \\\"       |
| 유니코드문자(16진수) | \\u#{유니코드} |


### 인코딩과 디코딩(encoding & decoding)
숫자(암호)를 문자로 변환하는 것을 인코딩(encoding), 문자를 숫자(암호)로 변환하는 것을 디코딩(decoding)이라고 한다.

기본적으로 컴퓨터는 숫자로 저장되며, 컴퓨터에서 숫자를 인코딩하여 문자를 표현하는 대표적인 방식 중 한가지가 유니코드(unicode)이다.
유니코드는 각 코드값에 따라 지정된 문자를 출력할 수 있다.
예를 들어 'A'를 유니코드로 65라는 값으로 지정되어 있다. 

웹페이지의 경우 어떤 형식으로 인코딩할 것인지가 포함되어 있어, 지정된 유형에 맞게 인코딩 혹은 디코딩된다. 

#### 아스키(ASCII, American Standard Code for Information Interchange)
128개의 문자집합(character set)을 제공하는 7bit의 부호이다. 
제어용으로 사용되는 처음 32개 문자와 마지막문자(DEL)을 제외한 33번째 이후의 문자를 출력하여 사용한다.
기호와 숫자, 영대소문자로 이루어져있다. 
0-9, A~Z, a~z 가 연속적으로 배치되어있다. 

#### 확장아스키(ExtendedASCII)
총 7bit로 사용되는 아스키에서 남는 1bit를 활용하여 문자를 추가로 정의한 것이다. 
여기에 추가된 128개의 문자는 여러 국가와 기업에서 서로의 필요에 따라 다르게 정의된다.
ISO(국제표준화기구)에서 확장 아스키의 표준을 수 가지 발표하여 일반적으로 사용되고 있다. 

컴퓨터에서 한글은 조합형과 완성형으로 표현되는데, 주로 사용되는 것은 완성형이다.
기존 완성형(KSC5601)에서 8822글자가 추가된 확장 완성형(CP949)이 주로 사용된다. 
기본적으로 한글 윈도우에 작성된 문서는 CP949로 인코딩되어 저장된다. 

#### 코드페이지(code page, cp)
IBM에서 자사 PC에 확장 아스키를 도입하여 사용하기 시작할 때 다양한 버전의 확장아스키가 필요하게 된다.
IBM은 이를 '코드페이지'라 부르고, 각 코드페이지에 CPxxx 등의 형식으로 이름을 명명하였다. 
한글 윈도우는 CP949를, 영문 윈도우는 CP438을 사용한다. 

#### 유니코드(Unicode)
웹이 발전하고 다른 언어 간의 문자교환이 빈번해지자 각 로컬문자로 소통하는데 어려움이 생겼다.
이러한 난점을 해소하고자 세계 각지의 문자를 하나의 통일된 집합으로 표현한 결과가 바로 유니코드이다. 
21bit(약 200만 문자)를 사용하여 문자를 표현하고 있다.
새로 추가된 문자들을 보충문자(supplementary character)라고 한다. 이러한 문자들을 표현하기 위해서는 int 타입을 사용해야 한다.

유니코드에 포함시키고자 하는 문자 집합을 정의한 것이 유니코드 문자셋(character set)이다. 
이러한 문자셋에 번호를 붙인 것이 유니코드 인코딩이다.
유니코드 인코딩에는 UTF-8, UTF-16, UTF-32 등 여러가지 종류가 있다.
Java에서는 UTF-16을 이용한다.
UTF-16은 모든 문자를 2byte의 고정크기로 표현하며, UTF-8은 1~4 byte라는 가변적인 크기를 가진다. 

인터넷에서는 전송속도가 중요하므로, UTF-8인코딩으로 작성된 웹문서의 수가 많다.

---

### 4-3 정수형(byte, short, int, long)

| byte     | short | int   | long  |
|----------|------|-------|-------| 
| 1byte    | 2byte | 4byte | 8byte |
| 8bit     | 16bit | 32bit | 64bit |

정수형 자료는 byte 단위로 통일되며, 4개의 자료형이 1~8byte까지 2배씩 크기가 증가한다. 
기본 자료형은 int 이다.

모든 정수형에는 부호가 있으므로, 첫번째 비트는 부호비트(sign bit)로 쓰이며, 나머지는 값을 표현하는데 사용된다.
범위 중 최대값에서 1을 빼게 되는데, 범위에 0이 포함되기 때문이다. 

일반적으로는 정수형을 선택할 때는 사용하려는 크기가 작다면 메모리를 절약하기위해 byte나 short를 선택하는 방법도 있다.
하지만 저장하는 범위가 작아 기본적으로 int를 사용하는 편이다. 

int타입이 표현가능한 정수의 개수는 40억(+-20억)이며, 일반적으로 int를 이용하며, 이 값을 벗어날 경우 long을 사용한다.

#### 정수형의 오버플로우
4bit 2진수의 최대값인 '1111'에 1을 더한다고 해서 에러가 발생하지는 않는다.
하지만 표현범위를 벗어난 값을 읽지 않아 '0000'으로 저장된다.
반대로 '0000'에서 1을 감소시킨다면, 저장되지 않은 1이 있다고 가정하고 뺄셈을 한다.
따라서 이는 바로 최대값으로 저장된다.
```
최대값 + 1 → 최소값
최소값 + 1 → 최대값
```

이처럼 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)라고 한다.
코드를 작성할 때는 이처럼 오버플로우가 발생할 수 있다는 것을 염두하여 충분한 크기의 타입을 선택하여야 한다.

---

### 4-4 실수형(float, double)


| 타입     | 정밀도  | bitb          |
|--------|------|---------------| 
| float  | 7자리  | 8byte(32bit)  |
| double | 15다리 | 16byte(64bit) |

#### 무한대(infinity)
실수형 변수를 표현할 때 변수의 값이 표현범위의 최대값을 벗어나면 변수의 값은 무한대가 된다.

#### 언더플로우(underflow)
최소값보다 작은 값이 될 때 변수의 값은 0이 된다.

#### 실수형의 저장형식 
| 기호 | 의미           | 설명                                                           |
|----|--------------|--------------------------------------------------------------| 
| S  | 부호(Sign bit) | 0: 양수, 1: 음수                                                 |
| E  | 지수(Exponent) | 부호있는 정수, 지수의 범위는 -127~128(float), -1023~1024(double)         |
| M  | 가수(Mantissa) | 실제값을 저장하는 부분. 10진수로 7자리(float), 15자리(double)의 정밀도로 저장할 수 있다. |
1. 부호 
 S. 0이면 양수, 1이면 음수를 의미한다.
2. 지수
 'E'는 지수를 저장하는 부분이다.
 최대값과 최소값(flaot의 경우 각각 -127, 128)은 숫자아님(Nan, Not a Number), 혹은 양의 무한대(POSITIVE_INFINITY)나 음의 무한대(NEGATIVE_INFINITY)처럼 특수한 값을 표현하기 위해 예약되어 있다. 

3. 기수 
 'M'은 실제값인 가수를 저장하는 부분이다.

| int   | S(1) | E(31) | -     |
|-------|------|-------|-------| 
| float | S(1)| E(8)  | M(23) |
int와 float은 둘 다 4byte(32bit)의 용량을 가지지만 표현범위가 다르다.
int의 표현범위는 부호 1bit, 지수 31bit 두 부분으로 이뤄져있다.
float의 표현범위는 부호 1bit, 지수 8bit, 가수 23bit 세 부분으로 이뤄져있다. 

실수형에 있어서 중요한 기준 중 하나는 정밀도(precision)이다. 
만일 7자리 이상의 정밀도가 필요할 경우 변수의 타입을 double로 하는 편이 좋다.
float: 연산속도 향상, 메모리 절약을 우선으로 한다면 float을 선택한다.
double: 값의 정밀도, 값의 범위를 우선으로 한다면 double을 선택한다. 
(※ double: float의 2배(double)의 정밀도를 갖고 있다는 뜻)

실수형 변수의 저장값은 다음과 같다. 
float: 1 + 8 + 23 (32bit) 4byte
double: 1 + 11 + 52 (64bit) 8byte

#### 부동소수점의 오차 
실수를 저장할 때는 2진수로 저장한다. 2진수로 변환된 실수를 저장할 때는 '1.xxx * 2ⁿ'의 형태로 변환하는데 이 과정을 정규화라고 한다.
가수의 마지막 비트단위를 벗어날 때 값이 잘려나가는데, 이때 잘려나간 값에 의해 오차가 발생한다.




