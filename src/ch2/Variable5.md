## 5. 형변환(casting)


### 5-1. 형변환(casting)
프로세스가 진행할 때 동일한 타입만이 아닌, 서로 다른 타입 간의 연산을 수행해야하는 경우가 생긴다. 
이때 연산을 수행하기 전에 타입을 일치시켜야한다. 
이렇게 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 형변환(casting)이라고 한다.
```
형변환: 변수, 또는 상수의 타입을 다른 타입으로 변환하는 것
```
---
### 5-2. 형변환 방법
형변환 방법은 아래와 같다.
``` 
(type) literal
```
여기에서 사용되는 괄호는 캐스트연산자(형변환연산자)라고 한다.
```java
// double 타입의 변수 d를 int 타입으로 형변환하는 과정
double d = 85.4;
int score = (int) d; // 이는 다음과 동일하다. → int score = (int) 85.4 → int score 85;
```

형변환 연산자는 피연산자의값을 읽어 지정된타입으로 형변환하고 그 결과를 반환한다. 
따라서 위의 예제의 경우 피연산자인 변수 d의 값은 형변환 후에도 변화가 없다.

기본형은 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다. 
또한 기본형과 참조형 간의 형변환은 불가능하다. 

| 변환          | 수식         | 결과    |
|-------------|------------|-------|
| int → char  | (char) 65  | 'A'   |
| char → int  | (int) 'A'  | 65    |
| float → int | (int) 1.6f | 1     |
| int → float | (float) 10 | 10.0f |

---

### 5-3. 정수형 간의 형변환
큰 타입에서 작은타입으로 변환하는 경우 크기의 차이만큼 잘려나간다.
따라서 이러한 경우에는 값 손실(loss of data)가 발생할 수 있다. 

반대로 작은 타입에서 큰 타입으로의 변환, 값을 int 타입으로 변환하는 경우는 저장공간 부족으로 잘려나가는 일은 없다.
나머지 공간은 0, 1로 채워진다.
(빈 공간은 0으로 채우는 게 보통이지만, 변환하려는 값이 음수인 경우 빈공간을 1로 채운다.)

---

### 5-4. 실수형 간의 형변환
실수형에서도 정수형과 같은 일이 벌어진다. 
단, 주의할 점이 몇 가지 있다.  
double에서 float으로 작은 타입으로 형변환할 시 가수의 24번째 자리가 1일 경우 반올림이 발생한다. 
float 타입의 범위를 넘는 값을 float으로 형변환하는 경우 ±무한대, 혹은 ±0을 결과로 얻는다. 

---

### 5-5. 정수형과 실수형 간의 형변환

#### 정수형 → 실수형 
정수는 소수점 이하 값이 없으므로, 정수를 2진수로 변환 후 정규화를 거쳐 실수형식으로 저장된다. 
실수형은 정수형보다 훨씬 큰 저장범위를 갖기 때문에, 정수형을 실수형으로변환하는 것은 별 무리가 없다. 

#### 실수형 → 정수형 
실수형의 소수점 이하의 값은 버려진다. 따라서 실수형을 정수형으로 형변환할 때 반올림은 발생하지 않는다. 

```
1.666  -(int)→ 1 
```
---
### 5-6. 자동 형변환
형번환이 선언되지 않더라도 컴파일러가 생략된 형변환을 자동적으로 추가하기도 한다.
이처럼 연산과정에서 자동적으로 발생하는 형변환을 '산술 변환'이라고 한다.

```java
 float f = 1234; // 형변환 생략. float f = (float) 1234; 와 같음
```
위의 예제에서 타입과 상수의 타입은 다르다. 단, 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하는 경우에서 변수형의 저장범위보다 더 큰 값이 선언될 경우 에러가 발생한다. 
```java
    byte b = 1000; // 에러. byte의 범위(-128~127)을 넘는 값이 저장되었다. incompatible types: possible lossy conversion from int to byte 에러 발생 
    (char) ch = (char) 1000; // 명시적 형변환. 컴파일러는 이를 의도적인 것으로 판단하여 에러가 발생하지 않는다.  
```

#### 자동형변환의 규칙
```
컴파일러는 기존의 값을 최대한 보놎ㄴ할 수 있는 타입으로 자동형변환한다. 
```
1. 표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값손실이 발생하지 않는다. 따라서 두 타입 중에서 표현범위가 넓은 쪽으로 형변환한다.
  ```
(자동형변환이 가능한 방향) byte → short → int || char → long → float → double
```
좌측에서 우측으로의 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 된다.
하지만 그 반대 방향으로의 변환은 반드시 형변환 연산자를 사용해주어야 한다.
일반적으로 자료형의 크기가 큰 것일 수록 값의 표현범위가 크기 마련이지만, 실수형은 정수형과 값을 표현하는 방식이 다르기 때문에 같은 크기일지라도 실수형이 정숳령보다 더 큰 표현범위를 갖는다. 
따라서 float, double이 같은 크기인 int, long보다 우측에 위치해있다.

(※ 정수형을 실수형으로 형변환하는 경우, 정밀도의 한계로 인한 오차가 발생할 수 있다)









